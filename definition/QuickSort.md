---
data: 2023.01.24
alias: []
tags: math
symbol:
page: [[[]],0]
---
Среднее время работы - $O(n\log n)$ для n элементных массивов

Он построен вокруг подпрограммы "частичной сортировки", задача которой состоит в том, чтобы делить массив вокруг "опорного элемента".

### Шаг 1: Выбрать опорный элемент
Сначала выбираем один элемент массива, который будет выступать в качестве опорного элемента, допустим элемент $p$.

### Шаг 2: Перегруппировать входной массив вокруг опорного элемента
При наличии опрного элемента следующая задача состоит в том, чтобы сгруппировать элементы массива так, чтобы все, что расположено в массиве перед p, было меньше p, а все, что после p, было больше p. 

### Пример:
{5,3,8,1,4,6,2,7} 5 - опорный, 3 - левый, 7 - правый
{5,3,2,1,4,6,8,7}
{4,3,2,1,5,6,8,7}
{1,3,2,4,5,6,8,7}
...
{1,2,3,4,5,6,7,8}

### Pseudocode
QuickSort

Вход: массив A из n разных целых чисел, левая и правая часть конечные точки, $l,r\in{1,2,\dots,n}$ 
Выход: элементы массива А отсортированы от наименьшего до наибольшего
if $l\geq r$ then // 0 - или 1 - элементный подмассив
	return
i := ChoosePivot(A,$l,r$) 
обменять $A[l]$ с $A[i]$       // сделать опорный первым
j := Partition($A,l,r$)           // j = новая опорная позиция
QuickSort($A,l,j-1$)       //рекурсивно взывать с первой частью
QuickSort($A,j+1,r$)      // рекурсивно вызывать со второй частью

Partition

Вход: массив $A$ из $n$ разных целых числе, левая и правая конечные точки, $l,r\in{\left\{ 1,2,\dots,n \right\}}$, где $l \leq r$
Постусловие: элементы подмассива $A[l],A[l+1],\dots,A[r]$ разделены вокруг $A[l]$
Выход: конечная позиция опорного элемента
p := $A[l]$
i := l + 1
for j := l + 1 to r do
	if $A[j] < p$ then         // если $A[j]>p$, ничего не делать
		обменять $A[j]$ с $A[i]$
		i := i++                                   // восстанавливает [[инвариант]]
обменять $A[l]$ с $A[i-1]$     // поместить опорный элемент правильно
return i - 1                                         // сообщить конечную позицию опорного элемента



### Разница между MergeSort и QuickSort
В MergeSort сначала выполняются рекурсивные вызовы, а затем шаг объединения, Merge . В алгоритме QuickSort рекурсивные вызовы происходят после разделения массива, и их результаты не нужно объединять вообще.

### Преимущество в оперативной памяти 
Преимущество данного алгоритма перед MergeSort заключается в том, что QuickSort выполнятеся на том же месте - он работает с входным массивом только путем повторяющегося прямого обмена пар элементов, и по этой причине требует выделения лишь небольшого объема доп оперативной памяти для промежуточных вычислений.


### Важность опорного элемента
Чтобы улучшить базовый вариант выбора опорного элемента - первый элемент, можно использовать элемент, для которого одинаковое количество других элементов меньше него и больше него. Медиана элемента массива может быть вычислена за время, линейное по длине массива. Пример, медианой массива, содержащего {1,2,3,...,9} будет 5. Если массив будет четной длинны, то можно использовать любой из двух элементов.