---
data: 2022.12.24
alias: [сдача курсовой работы по алгоритмам и структурам данных]
tags: testing 
---


23 of December we(Artem, I) passed 85 out of 100 point of it. That's "отлично" mark.

## Жадное планирование. Минимизация взвешенной суммы сроков завершения работ.
### Задание
1) реализовать алгоритм GreedyDiff (./code)
2) реализовать алгоритм GreedyRatio (./code)
3) Дать ответ на вопрос какова взвешенная сумма времени выполнения расписания, выводимого алгоритмами. (Устранять ничью в пользу работы с бОльшими весами) (diff = 68615)(ratio = 67247)
4) Сравнить временные затраты для задачи 1 и 2
5) Привести и обосновать асимптотическую оценку временной сложности обоих алгоритмов. [[#^ed4f41]]

### текст и решение
Главная книга для чтения - [[Рафгарден Т. - Совершенный алгоритм. Жадные алгоритмы и динамическое программирование (Библиотека программиста) - 2020.pdf]]

GreedyRatio - O(nlog(n))


Существуют разные парадигмы проектирования алгоритмов, одна из них - жадная парадигма. (Существует также парадигма "Разделяй и властвуй"). (стр. 22)

Если говорить о том, что такое жадная парадигма, то это можно выразить так:
`Итеративно конструировать решение посредством последова-тельности близоруких решений и надеяться, что в конце концов все получится.` (стр. 23) (**взять отсюда ссылку на формальное определение жадного алгоритма**)

Существует множество видов жадных алгоритмов, к примеру алгоритм Дейкстры -  поиск кратчайшего расстояние от стартовой вершины до любой другой. Их количество создает трудности при выборе конкретной реализации жадного алгоритма. 

Еще одной трудностью жадных алгоритмов является определение правильности выхода алгоритма для каждого возможного входа. 

Из всего вышесказанного делаем вывод: (стр.23)
1) Легко придумать один или несколько жаныщ алгоритмов.
2) Легко Проанализировать время выполнения алгоритма.
3) Трудно установить правилность алгоритма.

Одной из причин, по которой жадные алгоритмы труднодоказуемы заключается в том, что множество алгоритмов на самом деле не являются правильным на некоторых определенных входных данных, т.е. алгоритм не получит желаемый результат.  (стр.24)

Рассмотрим базовый жадный алгоритм в задаче планирования работ. 
#### Постановка задачи:
Предположим, что каждая *работа* $R_{i}$ имеет длину $L_{i}$, которая является мерой времени, нужной на завершение работы $R_{i}$. Например, продолжительность пары, лекции, смены и т.д. Кроме времени затрачиваемой на работу также существует важность работы или вес, который будем обозначать $w_{j}$. Таким образом, чем больше веса у работы, тем больший у нее приоритет и ее срочность выполнения.

Расписание работ конкретизиурет порядок выполнения работ, то есть говорит в каком порядке выполнять работы.(стр. 26) К примеру, если существует задача с $n$ работами, то существует $n!$ разных расписаний, что очень много. Если $n=10$, то $10! = 6$ миллионов, если $n=20$, то $n! = 2,4$ квантиллиона. (стр.28). Видим, что считать факториал разных расписаний не выход. 

Давайте введем *целевую функцию*, которая будет представлять срок завершения $C_{j}(\sigma)$ работы $j$ в расписании $\sigma$ есть сумма длин работ, предшествующих $j$ в $\sigma$, плюс длина самого $j$. Для чего его ввели будет объяснено чуть позже. Таким образом, срок завершения работы в расписании - это суммарное время, которое проходит до полной обработки работы.

В реальных задачах зачастую стремятся к минимальным срокам завершения работ, но компромиссы неизбежны - в любом расписании работы, запланированные ранее, убудут иметь и более ранние сроки завершения, а те, что запланированы ближе к концу, будут иметь более поздние сроки завершения. 
Один из способов решения компромиссов состоит в минимизации суммы взвешенных сроков завершения, что записывается так:
$$\underset{ \sigma }{ min }\sum_{j=1}^nw_{j}C_{j}(\sigma)$$
где минимизация выполняется над всеми $n!$ возможными расписаниями $\sigma$, а $C_{j}(\sigma)$ обозначает срок завершения работы $j$ в расписании $\sigma$. Это эквивалентно минимизации средневзвешенных сроков завершения работ, где усредняющие веса пропорциональны значениям $w_{j}$. (стр.27) К примеру, если взять работы с весами, равными $w_{1}=3,w_{2}=2,w_{3}=1$ и выполнять последовательно работы, то сроки завершения будут равны: 3 + 6 + 6 = 15. Проверив все возможные расписания можно убедиться, что это действительно является расписанием, которое минимизирует сумму взвешенных сроков завершения. 
Чтобы решить задачу в общем случае, не перебирая всевозможные варианты, нам понадобиться жадный алгоритм. Мы знаем, что более предпочтительной работой является та, что более короткая и с большим весом, но как поступить, если идет выбор между короткой с маленьким весом и длинной с большим весом?  Для данного случая можно ввести формулу, которая описывала две величины одной. В качестве реализации можно представить два варианта: 
1) GreedyDiff
2) GreedyRatio
Первый представляет разность вежду весом и длинной и-ой работы:
$j: w_{j}-l_{j}$
GreedyRatio, судя по названию, является отношением величин:
$j: \frac{w_{j}}{l_{j}}$
Эти две реализации приводят к двум разным алгоритмам вычисления ответа. Встает вопрос, а какой алгоритм дает лучшие результаты? Способ это сделать - найти экземпляр, в котором два алгоритма выводят разные расписания с разными значениями целевой функции. И тот алгоритм, чьи значения будут в сумме хуже показывать - не оптимальный.
Например возьмем 2 работы:
|       | Работа 1  | Работа 2  |
| ----- | --------- | --------- |
| Длина | $l_{1}=7$ | $l_{2}=3$ |
| Вес   | $w_{1}=4$ | $w_{2}=1$ | 

 Первая работа имеет более крупное отношение $\frac{4}{7}$  против $\frac{1}{3}$, но  большую разность (-3 против -2). Таким образом, алгоритм GreedyDiff планирует вторую работу первой, тогда как алгоритм GreedRatio планирует наоборот. 

Оба алгоритма сортируют массив значений согласно целевой функции, алгоритм сортировки - Quick Sort, который имеет асимптотику  O (n * log(n)), операция деления имеет O (1), следовательно общая асимптотика равна O (n * log (n)).  ^ed4f41


Время работы GreedyDiff - 426717 нс; GreedyRatio - 34885 нс.